# 🛡️ Web安全基础：双写绕过 (Double-Writing Bypass)

> **标签:** `Web安全`, `CTF`， `漏洞绕过`, `代码审计`, `WAF-Bypass`

## 📌 漏洞简介
在Web渗透测试中，“双写绕过”是一种针对黑名单过滤机制的经典绕过技术。
当目标系统使用**非递归**的字符串替换函数（即只执行一次删除或替换操作）来清理恶意关键字时，可以通过嵌套拼写关键字，使得字符串在被过滤一次后，剩下的字符刚好重新组合成完整的攻击载荷。

---

## ⚙️ 核心原理
漏洞的根源在于后端的防御逻辑不够严谨：**只过滤了一次，没有进行循环检查。**

**原理演示：**
假设后端过滤逻辑为 `$input = str_replace("select", ""， $input)`
1. 构造恶意输入：`selselectect`
2. 过滤执行：扫描到中间的 `select` 关键字，并将其删除。
3. 绕过成功：左侧剩余的 `sel` 和右侧剩余的 `ect` 自动拼接，再次生成了完整的 `select` 关键字，随后的逻辑将执行该恶意指令。

---

## 🎯 常见场景与 Payload 速查表

### 1. SQL 注入 (SQLi)
常用于绕过对特定 SQL 语法的黑名单过滤。
* **目标:** `union`  👉 **双写 Payload:** `ununionion`
* **目标:** `select` 👉 **双写 Payload:** `selselectect`
* **目标:** `or`     👉 **双写 Payload:** `oorr`
* **目标:** `and`    👉 **双写 Payload:** `aanndd`

### 2. 跨站脚本攻击 (XSS)
常用于绕过对 HTML 标签或常见事件（如 `onerror`）的过滤。
* **目标:** `script` 👉 **双写 Payload:** `<scrscriptipt>alert(1)</script>`
* **目标:** `onerror`👉 **双写 Payload:** `<img src=x ononerrorerror=alert(1)>`

### 3. 目录穿越 / 文件包含 (Path Traversal / LFI)
常用于绕过对 `../` 路径跳转符的防御限制。
* **目标:** `../`    👉 **双写 Payload:** `..././` 或 `....//`
  > *解析：系统删除中间的 `../` 后，剩下的 `.` 和 `./` 再次拼接成跨目录符号 `../`*

---

## 💻 代码审计视角

**❌ 易受攻击的代码示例 (PHP):**
```php
$input = $_GET['id'];
// 仅执行一次替换，存在双写绕过风险
$filtered_input = str_replace("script", ""， $input);
✅ 修复建议:

治标：递归/循环过滤

PHP
$input = $_GET['id'];
// 只要输入中还包含 script，就一直循环删除
while(preg_match("/script/i", $input)) {
    $input = preg_replace("/script/i", "", $input);
}
治本：弃用黑名单，采用安全规范

SQLi 防御： 强制使用预编译语句 (PDO / Prepared Statements)。

XSS 防御： 使用 HTML 实体编码输出 (如 htmlspecialchars())。

总体原则： 尽量采用白名单机制校验用户输入，而非尝试穷举所有坏字符。

🛠️ 实战测试技巧
在日常刷题或实战中，遇到疑似只替换一次的黑名单过滤点，可以结合 Burp Suite 进行高效验证：

将拦截到的请求发送至 Intruder 模块。

将可能被过滤的关键字参数（如注入点）设置为 Payload 标记位置。

挂载包含常见“双写变种”的字典，或者在 Payload Processing 中设置规则，自动生成双写结合大小写混淆的变形载荷（如 SeSelectlEcT），进行批量 Fuzz 测试。
