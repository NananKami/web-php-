# 🛡️ CTF Web 方向：PHP 代码审计速查笔记

在 CTF 的 PHP 代码题中，出题人的逻辑通常是：**暴露一个输入点 -> 经过层层过滤（或没有过滤） -> 进入一个危险函数执行**。我们的目标就是想办法让 Payload 活到最后并被执行。

## 一、 门面担当：数据输入点（全局变量）

在 Web 环境中，数据永远来自 HTTP 请求。必须盯死以下几个数组：

* **`$_GET['参数名']`**：接收 URL 中 `?参数名=值` 的数据。（最常见，直接在地址栏操作）
* **`$_POST['参数名']`**：接收 HTTP POST 请求体里的数据。（通常需要用 HackBar、Burp Suite 或 ZAP 抓包修改）
* **`$_REQUEST['参数名']`**：通吃型！无论是 GET 还是 POST 传来的同名参数，它都能接收。
* **`$_COOKIE['参数名']`**：接收缓存在浏览器里的 Cookie 数据。

> **💡 笔记要点：** 只要在源码里看到这几个词，就意味着“**这里可以被我控制**”。

## 二、 核心爆破点：危险函数大赏

拿到源码，先 `Ctrl+F` 搜索有没有以下高危函数：

### 1. 代码执行类（把字符串当 PHP 代码跑）
* **`eval($代码)`**：最经典的漏洞函数。必须传入完整的 PHP 语句（以分号 `;` 结尾）。
* **`assert($代码)`**：断言函数，和 `eval` 类似，但不需要分号结尾也能执行。

### 2. 命令执行类（直接调用系统底层 shell）
* **`system($命令)`**：执行系统命令，且自带 `echo` 效果，直接把结果回显在网页上。（最好用）
* **`exec($命令, $数组)`**：执行命令，**默认不回显**结果，只会返回最后一行。
* **`passthru($命令)`**：执行命令，直接把原始数据流输出到浏览器。

### 3. 文件读取/包含类（偷看 Flag 专用）
* **`highlight_file($文件名)` / `show_source()`**：把 PHP 文件的源码高亮显示在网页上。
* **`file_get_contents($文件名)`**：把文件内容全读出来变成一个字符串。
* **`include($文件名)` / `require()`**：文件包含漏洞的核心函数。

## 三、 CTF 必考的“黑魔法”（PHP 弱类型特性）

### 1. 弱类型比较 (`==` 与 `===`)
* **`===` (强等于)**：比较数值和类型。`1 === "1"` 是 **False**。
* **`==` (弱等于)**：只比较数值，会在后台自动转换类型！`"admin" == 0` 在 PHP 8.0 以下为 **True**。

### 2. MD5 碰撞绕过
* **考点：** `if (md5($a) == md5($b) && $a != $b)`
* **原理：** PHP 处理 `0e` 开头的字符串进行 `==` 比较时，会视作科学计数法，结果全为 0。
* **解法：** 传入算出来 MD5 值均为 `0e` 开头的不同字符串（如 `QNKCDZO` 和 `240610708`）。

## 四、 解题通用 SOP (标准操作流程)

1. **审阅全局：** 寻找 `$_GET` 等输入点。
2. **锁定目标：** 寻找 `eval`、`system` 等危险函数，观察变量流向。
3. **分析路障：** 检查输入点和目标之间的 `if` 过滤规则。
4. **构造 Payload：**
   * 思考如何**闭合**原有的语法（如 `);` ）。
   * 插入恶意代码（如 `system('cat flag.php');` ）。
   * 思考如何**注释**掉尾部代码（如 `//` ）。
5. **查看结果：** 页面无变化时，**Ctrl + U** 查看网页源代码。
